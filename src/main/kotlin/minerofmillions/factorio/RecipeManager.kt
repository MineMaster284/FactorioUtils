/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package minerofmillions.factorio

import com.google.gson.GsonBuilder
import com.google.gson.reflect.TypeToken
import minerofmillions.factorio.recipe.*
import java.io.File

class RecipeManager(private val listerOutput: RecipeListerOutput) {
    private val recipes = listerOutput.recipe.filterValues { !isStackOrBarrelRecipe(it) }

    val inputs by lazy {
        recipes.values.flatMap { r -> r.ingredients.mapNotNull { it.name } }.toSortedSet()
    }
    val outputs by lazy {
        recipes.values.flatMap { r -> r.products.mapNotNull { it.name } }.toSortedSet()
    }

    val recipesByInput by lazy {
        inputs.associateWith { input ->
            recipes.filterValues { r -> r.ingredients.any { it.name == input } }.toSortedMap()
        }
    }
    val recipesByOutput by lazy {
        outputs.associateWith { output ->
            recipes.filterValues { r -> r.products.any { it.name == output } }.toSortedMap()
        }
    }

    private val depthCache = mutableMapOf<String, Int>()
    fun getDepth(item: String): Int = getDepth(item, emptyList())
    private fun getDepth(item: String, memo: List<String>): Int = when {
        item in depthCache -> depthCache[item]!!
        item in memo -> 0
        "stack" in item -> 0
        "barrel" in item -> 0
        else -> ((itemsByChild[item]
            ?.map { getDepth(it, memo + item) }
            ?.max() ?: 0) + 1).also { depthCache[item] = it }
    }

    val itemsByParent by lazy {
        inputs.associateWith { input ->
            recipesByInput[input]?.values?.flatMap(Recipe::products)?.map(Ingredient::name)?.toSortedSet()
        }
    }
    val itemsByChild by lazy {
        outputs.associateWith { output ->
            recipesByOutput[output]?.values?.flatMap(Recipe::ingredients)?.map(Ingredient::name)?.toSortedSet()
        }
    }
}

fun main() {
    val gson = GsonBuilder()
        .setPrettyPrinting()
        .registerTypeAdapter(AssemblingMachine::class.java, AssemblingMachine.Serializer)
        .registerTypeAdapter(Boiler::class.java, Boiler.Serializer)
        .registerTypeAdapter(Fluid::class.java, Fluid.Serializer)
        .registerTypeAdapter(Furnace::class.java, Furnace.Serializer)
        .registerTypeAdapter(Generator::class.java, Generator.Serializer)
        .registerTypeAdapter(Ingredient::class.java, Ingredient.Serializer)
        .registerTypeAdapter(Item::class.java, Item.Serializer)
        .registerTypeAdapter(Reactor::class.java, Reactor.Serializer)
        .registerTypeAdapter(Recipe::class.java, Recipe.Serializer)
        .registerTypeAdapter(TransportBelt::class.java, TransportBelt.Serializer)
        .create()
    File("src/main/resources/data").listFiles()?.forEach { input ->
        if (input.isFile) {
            println(input.name)
            val listerOutput = input
                .reader()
                .use {
                    gson.fromJson(it, RecipeListerOutput::class.java)
                }
            File(input.name).writer().use {
                gson.toJson(listerOutput, it)
            }
        }
    }
}

fun isStackOrBarrel(ingredient: Ingredient): Boolean = "stack" in ingredient.name || "barrel" in ingredient.name
fun isStackOrBarrelRecipe(recipe: Recipe): Boolean =
    recipe.ingredients.any { isStackOrBarrel(it) } || recipe.products.any { isStackOrBarrel(it) }
